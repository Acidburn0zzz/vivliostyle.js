/* page decoration */
@page :left {
	@bottom-left-corner { content: counter(page); }
}
@page :right {
	@bottom-right-corner { content: counter(page); }
}
@page :blank {
	@bottom-left-corner { content: none; }
	@bottom-right-corner { content: none; }
}

/***** Adjustments to look prettier *****/
a.self-link {
	border-bottom: none !important;
}

table {
	overflow-wrap: normal !important;
	word-wrap: normal !important;
}
table th {
	hyphens: none !important;
}
table.index td {
	word-break: keep-all;
	hyphens: none !important;
}

pre {
	overflow-wrap: normal !important;
	word-wrap: normal !important;
}

/***** pagination tweaks *****/
hr[title="Separator for header"] {
	display: none;
}

.head dd, .head .copyright {
	break-before: avoid;
}

.head {
	break-after: page;
}

#toc {
	break-before: left;
	break-after: left;
}

#references, #index, #property-index, #issues-index {
	break-before: page;
}

.toc li:last-of-type, .toc li:first-of-type {
	break-before: avoid;
}
ul.index li > ul {
	break-before: avoid;
}
table caption { break-after: avoid; }

/* Web-IDL spec specific */
.warning-title,
.blockTitleDiv,
.exampleHeader,
.note-title {
	break-after: avoid;
	break-inside: avoid;
}
/* end Web-IDL spec specific */

/***** TOC & cross references *****/
.toc a[href] {
	display: flex !important;
	align-items: baseline;
}
.toc li:last-child, .toc li:first-child {
	break-before: avoid;
}
.toc a[href]::after {
	content: target-counter( attr(href,url), page);
	flex:none;
	order: 2;
	padding-left: 1ch;
	margin-left: auto;
	text-align: right;
	align-self: flex-end;
}
.toc a[href]::before {
	/* Simulate a leader */
	content: "";
	order: 1;
	flex: auto;
	margin-left: 1ch;
	border-bottom: solid 1px lightgrey;
}

/* Redo the indentation model of the TOC in a way that's compatible with flexbox */
:not(li) > .toc { margin-left:  0rem; }
.toc .secno {
	float: none;
	margin-left: 0;
	display: inline-block;
	width: 5rem;
	flex: none;
}
.toc > li li li { margin-left: 0; }
.toc > li li li .secno { margin-right: 2rem; }
.toc > li li li li .secno { margin-right: 4rem; }
.toc > li li li li li .secno { margin-right: 6rem; }
@media (max-width: 40em) {
	.toc .secno                  { width: 4rem; }
	.toc > li li li .secno       { margin-right: 1rem; }
	.toc > li li li li .secno    { margin-right: 2rem; }
	.toc > li li li li li .secno { margin-right: 3rem; }
}

/***** Index & cross references *****/
ul.index a[href^="#"]::after {
	content: ", p.\00200a" target-counter( attr(href,url), page);
	color: black;
	border-bottom: solid 1px white;
}

/***** Dealing with large elements *****/
img, svg {
	max-width: 100%;
	object-fit: contain;
}
table img {
	max-width: none;
}

figure, .figure {
	display: flex;
	flex-flow: column;
	align-items: center;
	/* not 100vh, to leave just a bit of room if the figure is in something that has a border */
	max-height: 95vh;
	max-height: calc(100vh - 6px); /* The thickest vertical border we have is 3px, and that's in case there's two of it */
}
figure > figcaption, .figure > .caption {
	flex: none;
	display: block;
}
figure > *, .figure > * {
	flex: auto;
	overflow: auto;
}
.figure > a,
figure > a {
	display: flex;
	flex-flow: column;
	align-items: center;
	padding: 0 !important;
	margin: 0 !important;
	border-bottom: none !important;
}

pre.ascii-art,
pre.output,
div.figure pre, div.sidefigure pre, figure pre {
	display: block !important;
	width: max-content;
	/* The next two lines wouldn't work if we were display: table */
	max-width: 100%;
	box-sizing: border-box;
	overflow: auto;
}

html { background: white !important; }

body,
pre,
.big-element-wrapper,
.overlarge {
	overflow: auto !important;
	background: left / 4em 100% linear-gradient(to right, white, white 1em, rgba(255,255,255,0)) local,
	            right / 4em 100% linear-gradient(to left, white, white 1em, rgba(255,255,255,0)) local,
	            left 1px center / 1.2em 90% radial-gradient(at left, rgba(0,0,0,.25), transparent 70%) scroll,
	            right 1px center / 1.2em 90% radial-gradient(at right, rgba(0,0,0,.25), transparent 70%) scroll
	            white !important;
	background-repeat:  no-repeat !important;
	box-decoration-break: clone;
}
.example, .example > pre {
	overflow: auto !important;
	background: left / 4em 100% linear-gradient(to right, #FCFAEE, #FCFAEE 1em, rgba(255,255,255,0)) local,
	            right / 4em 100% linear-gradient(to left, #FCFAEE, #FCFAEE 1em, rgba(255,255,255,0)) local,
	            left 1px center / 1.2em 90% radial-gradient(at left, rgba(0,0,0,.25), transparent 70%) scroll,
	            right 1px center / 1.2em 90% radial-gradient(at right, rgba(0,0,0,.25), transparent 70%) scroll
	            #FCFAEE !important;
	background-repeat:  no-repeat !important;
}
.note, .note > pre {
	overflow: auto !important;
	background: left / 4em 100% linear-gradient(to right, #E9FBE9, #E9FBE9 1em, rgba(255,255,255,0)) local,
	            right / 4em 100% linear-gradient(to left, #E9FBE9, #E9FBE9 1em, rgba(255,255,255,0)) local,
	            left 1px center / 1.2em 90% radial-gradient(at left, rgba(0,0,0,.25), transparent 70%) scroll,
	            right 1px center / 1.2em 90% radial-gradient(at right, rgba(0,0,0,.25), transparent 70%) scroll
	            #E9FBE9 !important;
	background-repeat:  no-repeat !important;
}

@media (overflow-inline: none) {
	/* On screen, dealing with a scrollbar is fine,
	 * but when printing, we need something more drastic.
	 * This media query isn't really the right one,
	 * since we're not actually overflowing the viewport
	 * but it is a good proxy for what we want:
	 * are we in a mode where scrolling makes sense or not. */
	pre {
		overflow: visible;
		white-space: pre-wrap;
		overflow-wrap: break-word !important;
		word-wrap: break-word !important;
	}
	pre.ascii-art {
		/* This is going to overflow and that's ugly,
		   but ascii-art cannot be wrapped */
		display: table !important;
		white-space: pre !important;
	}
	.big-element-wrapper,
	.overlarge,
        .note,
	.example {
		overflow: visible;
	}
	table {
		overflow-wrap: break-word; !important;
		word-wrap: break-word; !important;
	}
	table th {
		hyphens: manual !important;
	}
	table.index td {
		word-break: normal;
		hyphens: manual !important;
	}
}

.big-element-wrapper > table,
.overlarge > table {
	/* limit preferred width of table */
	max-width: 50em;
	margin-left: auto;
	margin-right: auto;
}

@media (max-width: 40em) {
	table.index tbody th {
		writing-mode: sideways-lr;
	}
}

/***** Bug fixes *****/
a.self-link {
	left: -epubx-expr(-1 * (3.5rem - 26px));
	width: -epubx-expr(3.5rem - 26px);
}
li > a.self-link {
	left: -epubx-expr(-1 * (3.5rem - 26px) - 2em);
}
body {
	padding: 1.6em 1.5em 2em -epubx-expr(26px + 1.5em);
}

* { box-decoration-break: slice; /* should not be inherited, reset */ }

